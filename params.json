{"name":"Parsekit","tagline":"Using ParseKit to rapidly implement parsers for iOS or Mac applications.","body":"Hey there, it looks like you're trying to parse text input in Objective-C. You've come to the right place.\r\n\r\nParseKit is a parser generator implemented in Objective-C, which converts grammars into parsers intended for use in Cocoa applications running on iOS or Mac OS X.\r\n\r\nWith ParseKit, you can define your language with a high-level, easy-to-use, BNF-style grammar, and ParseKit will generate source code for a parser for your language.\r\n\r\nSpecifically, parsers produced by ParseKit are **recursive descent**, **deterministic**, **packrat**, **LL(k)** (this is, *infinite-lookahead*) parsers written in Objective-C. That's a mouthful, but what it means in practice is that ParseKit offers you a great deal of flexibility and expressive power when designing your grammars, but also produces parsers which exhibit good (linear) performance characteristics at runtime. Also, the Objective-C code produced by ParseKit is clean, readable, and easy to debug or tweak by hand.\r\n\r\n\r\nThe design of ParseKit has been heavily influenced by [ANTLR](http://antlr.org) and a [book by Stephen J Metsker](http://www.amazon.com/Building-Parsers-Java-Steven-Metsker/dp/0201719622).\r\n\r\nIn this tutorial, I'll show how to use ParseKit to implement a small \"MiniMath\" expression language in an iOS application.\r\n\r\n### Desginging the Grammar\r\n\r\nFirst, let's design a ParseKit grammar for our \"MiniMath\" language. \"MiniMath\" should allow expressions like:\r\n\r\n    1            // bare numbers\r\n    2 + 2 + 42   // addition (including repetition)\r\n    2 * (2 + 4)  // multiplication and sub-expressions\r\n\r\nOK, now that we know what the expected input looks like, let's build the grammar. Every ParseKit grammar has to start with a rule called `@start`. Since MiniMath is an expression language, let's define our `@start` rule as an expression.\r\n\r\n    @start = expr;\r\n\r\nBut how do we define `expr`?\r\n\r\n    expr =  ???  // TODO\r\n\r\nRather than designing our grammar from the top down, let's hold that thought, and work from the bottom up instead.\r\n\r\nWorking from the bottom, we'll start with a rule called `atom`. And since MiniMath deals with numbers, we'll define `atom` as a `Number`.\r\n\r\n    atom = Number;\r\n\r\nNotice how the rules we define ourselves (like `expr` and `atom`) start with lowercase letters. There are also built-in terminal rules like `Number`, `Word`, `QuotedString` and more. The built-in rules always start with uppercase letters, while the rules we define ourselves must start with lowercase letters.\r\n\r\nThe built-in `Number` rule matches a series of digits as you would expect. By default, it also matches optional floating-point and exponential parts of a number (this behavior is easily configurable).\r\n\r\nNow that we have defined an `atom` rule, let's define a primary expression.\r\n\r\n    primary = atom | '(' expr ')';\r\n\r\nA `primary` expression is either an atom or a parenthesized sub expression. The parentheses here can be used to alter operator precedence.\r\n\r\nNotice how we are using recursion to call our own `expr` rule. There is no problem with that (although in ParseKit grammars, you must always avoid [left recursion](http://en.wikipedia.org/wiki/Left_recursion)). \r\n\r\nNow let's move on to multiplication and addition. As usual, we want multiplication to bind more tightly than addition. Since we are working from the bottom up, we can make multiplication bind more tightly by defining it first.\r\n\r\nLet's define multiplication as a primary expression times a primary expression.\r\n\r\n    multExpr = primary '*' primary;\r\n\r\nBut we want to allow repetition in our multiplication expressions, like `2 * 8 * 0`, so we'll change our `multExpr` rule by wrapping the operator and the right-hand side operand in an optional repetition using `*`.\r\n\r\n    multExpr = primary ('*' primary)*;\r\n\r\nOur addition rule will look very similar:\r\n\r\n    addExpr = multExpr ('+' multExpr)*;\r\n\r\nSince our addition rule is defined in terms of multiplication operands, this will force multiplication to bind more tightly than addition. \r\n\r\nNow we can define our `expr` rule as an addition expression:\r\n\r\n    @start = expr;\r\n    expr = addExpr;\r\n\r\n\r\nFinally, let's change our grammar to discard unnecessary tokens. The post-fix `!` operator can be used to discard a token which is not needed to compute a result. In the case of MiniMath, we'll want to discard any token that is not a number (all of the literal strings in our grammar).\r\n\r\nHere's the complete grammar:\r\n\r\n    @start = expr;\r\n    expr = addExpr;\r\n    addExpr = multExpr ('+'! multExpr)*;\r\n    multExpr = primary ('*'! primary)*;\r\n    primary = atom | '('! expr ')'!;\r\n    atom = Number;\r\n    \r\n### Adding Actions to the Grammar\r\n\r\nOK, so we designed a grammar for our MiniMath language that can be fed to ParseKit to produce Objective-C source code for our parser.\r\n \r\nBut we don't just want to parse input, we also want to compute a result. The easiest way to do this is to use **grammar actions**. Grammar actions are small pieces of Objective-C source code embedded directly in a ParseKit grammar.\r\n\r\nWe'll start by adding an Action to the `atom` rule:\r\n \r\n    atom = Number \r\n    {\r\n        PKToken *tok = [self.assembly pop]; // pop the Number token\r\n        NSAssert(tok.isNumber, @\"a number token just matched in `atom`\");\r\n        \r\n        NSNumber *n = @(tok.floatValue);\r\n        [self.assembly push:n];  // push an NSNumber object\r\n    };\r\n    \r\nAs you can see, actions are blocks of Objective-C code enclosed in curly braces and placed after any rule reference.  In any action, there is an `assembly` object available which serves as a **stack**. The `assembly`'s stack contains the most recently parsed tokens (instances of `PKToken`), and also serves as a place to store your work as you compute the result.\r\n\r\nActions are executed immediately after their preceeding rule matches. So tokens which have recently been matched are available at the top of the `assembly`'s stack.\r\n\r\nIn this case, we are popping a number token off the stack, converting it to a float value, and pushing an `NSNumber` back onto the stack for later use.\r\n\r\nParseKit includes some handy macros that can make this code more concise. Here's the `atom` rule and action rewritten using those macros:\r\n\r\n    atom = Number { \r\n        // pop a token off the stack and push it back as a float value \r\n        PUSH_FLOAT(POP_FLOAT()); \r\n    };\r\n\r\nThis shortened action is exactly equivalent to the more verbose version above.\r\n    \r\nNow let's add an action to perform multiplication in the `multExpr` rule:\r\n\r\n    multExpr = primary ('*'! primary { \r\n        NSNumber *rhs = [self.assembly pop];\r\n        NSNumber *lhs = [self.assembly pop];\r\n        NSNumber *n = @([lhs floatValue] * [rhs floatValue]);\r\n        [self.assembly push:n];\r\n    })*;\r\n\r\nThis action executes immediately after the multiply operator (`*`) and right-hand side `primary` operand have been matched. Since the `*` operator has been discarded,  we can be assured that the top 2 objects on the stack are NSNumbers placed by our `atom` rule action.  \r\n\r\nAgain, we can use ParseKit's handy built-in macros to simplify our Objective-C action code. Here's the same action simplified:\r\n\r\n    multExpr = primary ('*'! primary { \r\n        PUSH_FLOAT(POP_FLOAT() * POP_FLOAT());\r\n    })*;\r\n\r\nFinally, we'll need a similar action for our addition expression rule. Here's the complete grammar including actions:\r\n\r\n    @start = expr;\r\n    expr = addExpr;\r\n    addExpr = multExpr ('+'! multExpr {\r\n        PUSH_FLOAT(POP_FLOAT() + POP_FLOAT());\r\n    })*;\r\n    multExpr = primary ('*'! primary { \r\n        PUSH_FLOAT(POP_FLOAT() * POP_FLOAT());\r\n    })*;\r\n    primary = atom | '('! expr ')'!;\r\n    atom = Number { \r\n        PUSH_FLOAT(POP_FLOAT()); \r\n    };\r\n    \r\n\r\n### Interlude: Checkout the Example App (and ParseKit Dependency)\r\n\r\n\r\n\r\n\r\n### Generating Parser Source Code\r\n\r\nNow that our MiniMath grammar is complete, we can use ParseKit to generate Objective-C source code for our parser.\r\n\r\nOpen the ParseKit Xcode project, then select and run the **ParserGenApp** target.\r\n\r\nPaste the MiniMath grammar into the large text area at the bottom of the ParseGenApp window, and select the options shown below.\r\n\r\nIMG\r\n\r\n\r\nClick the **Generate** button and notice that a MniniMathParser.h MniniMathParser.m file have been created, and appear on your Desktop. You'll need to drag this source code into your app's Xcode project.\r\n\r\nIMG\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}